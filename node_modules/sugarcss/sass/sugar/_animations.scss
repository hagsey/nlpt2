//
// Animations specific
//

//
// Animate mixin
//
@mixin s-animation(
	$animations...
) {
	// loop on animations
	$anims : ();
	$current_delay : 0s;
	$current_duration : 0s;
	$previous_duration : 0s;
	@each $animation in $animations {
		$animation : _sugar-parse-properties($animation, (
			iteration : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 infinite initial inherit,
			direction : normal reverse alternate alternate-reverse initial inherit,
			fill-mode : none forwards backwards both initial inherit,
			name : string,
			duration : second,
			delay : second,
			ease : string,
			parallel : true
		), (
			name : n,
			duration : du,
			delay : de,
			ease : e,
			iteration : i iteration-count,
			direction : di,
			fill-mode : fm,
			parallel : p
		));

		$name : map-get-or($animation, name);
		$duration : map-get-or($animation, duration, 1s);
		$delay : map-get-or($animation, delay, 0s);
		$ease : map-get-or($animation, ease, ease-in-out);
		$iteration : map-get-or($animation, iteration, 1);
		$direction : map-get-or($animation, direction, normal);
		$fill-mode : map-get-or($animation, fill-mode, forwards);
		$parallel : map-get-or($animation, parallel, false);
		
		// update delay
		$current_delay : $current_delay + $delay;

		// extend the animation if exist
		@extend %#{$name} !optional;
		
		// create the animations list	
		$anims : append($anims, $name $duration $current_delay $ease $iteration $direction $fill-mode, comma);
		
		// manage if animation is parallel with next one
		@if type-of($iteration) == number {
			@if $parallel == false {
				$current_delay : $current_delay + $duration * $iteration;
			}
		}
	}
	
	// set animation
	animation: $anims;
}

//
// Transition
//
@mixin s-transition(
	$transitions...
) {
	$trans : ();
	@if length($transitions) == 0 {
		$trans : append($trans, sugar('settings.transition.property') sugar('settings.transition.duration') sugar('settings.transition.ease') sugar('settings.transition.de√©ay'), comma);
	} @else {
		$transitions-settings : sugar('settings.transition.transitions');
		@each $transition in $transitions {
			// check if a transition exist in settings
			@if type-of($transition) == string and map-get($transitions-settings, $transition) {
				$t : map-get($transitions-settings, $transition);
				@if type-of($t) == map {
					$trans : append($trans, map-get($t, transition), comma);
				} @else {
					$trans : append($trans, $transition, comma);
				}
			} @else {
				$tran : _sugar-parse-properties($transition, (
					property : string,
					duration : number,
					ease : string,
					delay : number
				));
				$property : map-get-or($tran, property, sugar('settings.transition.property'));
				$duration : map-get-or($tran, duration, sugar('settings.transition.duration'));
				$delay : map-get-or($tran, delay, sugar('settings.transition.delay'));
				$ease : map-get-or($tran, ease, sugar('settings.transition.ease'));
				$trans : append($trans, $property $duration $ease $delay, comma);
			}
		}
	}
	$trans : append($trans, outline-color 0.000001s linear 0s, comma);

	// set transition
	transition: $trans;
	outline-color : black;
}

//
// Transition start trigger
//
@mixin s-transitionstart() {
	outline-color : rgba(random(255), random(255), random(255), random(1));
}

//
// DOMNodeInserted event hook
//
@keyframes s-DOMNodeInserted {
	from { opacity: .99; }
	to { opacity: 1; }
}
@function s-domnodeinserted() {
	@return s-DOMNodeInserted 0.001s;
}
@mixin s-DOMNodeInserted() {
	@include s-animation(s-domnodeinserted());
}	
@mixin s-domnodeinserted() {
	@include s-DOMNodeInserted();
}